Solution.py中是第一种方法，使用动态规划。从最后位置开始，逆向执行。分别查找当前位置到最后位置的最长匹配长度并记录在一个数组中，最后一个位置开始的最长匹配长度为0。当查找第i位置的最长匹配时，方法如下：如果第i位置上的字符是右括号，当前位置的最长匹配直接为0，跳过；如果第i位置上的字符为左括号，找到从i+1位置开始的最长匹配串，在不越界的情况下查看其后面一个位置，如果是左括号，则i位置最长匹配长度为0；如果是右括号，则形成了从i到该位置的新匹配，该位置后面如果还未越界，加上其后一位开始的最长匹配串，即为从i开始的最长匹配串。记录下长度。
最后，返回记录的长度中的最大值。

Solution1.py中是第二种方法。这个方法比较巧妙。直接采用从头开始进行扫描，如果是左括号，将其索引压栈；如果是右括号，栈内非空，说明二者形成了匹配，将栈顶弹出，并对这两个字符的索引位置标记为true。最后对所有的标记进行一遍扫描，最长连续为true的长度即为最长匹配。
