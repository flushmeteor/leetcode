思路就是从头开始对字符串遍历计算最长子串长度。当遇到两个字符出现了重复的时候（比如在索引i和索引j处都出现了字符a），从第一个重复字符的下一个字符（索引i+1处的字符）开始继续遍历。
    
这个程序采用了hashmap来记录出现过的字符及出现次数，当出现重复字符的时候，将索引i和之前的字符出现次数都减1。然后往下接着遍历。每往后移动一个字符的时候都计算一次最大长度。

其实这个程序的时间复杂度还可以进行一次优化。将hashmap中记录的出现次数改为记录该字符出现的位置。这样，当出现重复的时候，可以立马找到应该退回重新开始的位置，而不用对前面的所有字符进行遍历将出现次数减1。
