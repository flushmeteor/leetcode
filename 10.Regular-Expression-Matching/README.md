折腾了三天，终于做出来了，泪奔

特殊情况很难考虑完整。出现a*b*这种字符的时候很容易就出错了。

最后采取最粗暴的方式。
- 由于正想读取的时候对“*”这种字符需要预读取，所以采用了倒序匹配
- 先把.*左右的a*这种字符去掉，因为.*能代表它们了。
- 然后，如果遇到.*这种字符，拿p中当前位置之前的字符串作为新的模式p，与s当前位置之前的字符串比对，如果相同返回true；如果不同，在当前位置前移一位，用这位之前的字符串进行比对，如果相同，返回true，否则，循环当前操作直到s越界。如果直到s越界也没匹配成功，那么，返回false。
- 如果遇到a*这种字符，先记录下s的当前索引位置starIndex。拿p去和s匹配，直到p或s中有一个越界或者p遇到了不是a*这种格式的符号。
  停止后，有四种情况：
  
  （1）p没越界，s没越界。这说明p遇到了不是a*的字符，那么拿p当前位置之前的字符串作为新的模式p，与s当前位置之前的字符串进行比对，如果相同返回true；如果不同，将s的当前位置后移一位，用这位之前的字符串进行比对，如果相同返回true，否则，循环当前操作直到索引starIndex。如果直到starIndex位置也没匹配上，返回false。
  （2）p没越界，s越界了。如果p剩下的部分都是a*格式，返回false。如果p剩下部分有普通字符，用普通字符之前的字符串去比对，比对的对象是starIndex之前所有位置到开头的字符串，如果有匹配成功的，返回true；否则，返回false。
  （3）p越界了，s没越界。那么怎么样都不能和s剩下部分匹配上了，返回false
  （4）p越界了，s也越界了。说明正好匹配完。返回true。
  
- 如果遇到的是普通字符，直接比对。如果p中是“.”就直接匹配成功，如果不是“.”看是否和s中字符匹配成功，如果匹配成功，往前移动一个字符。如果匹配不成功，返回false。

- 如果从上面的比对中跳出来了，有以下几种情况
 （1）p越界了
 （2）s越界了
 这里处理的绝对不会是从带*字符处遗留的问题，因为上面的处理处都已经完全返回结果了。所以处理就简单了。如果s没匹配完，返回false。如果p没匹配完，剩下部分都是带*的字符串，返回true，否则false。
